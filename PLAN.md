# School Billing API – Execution Plan

## Step 0: Project Initialization ✅
- [x] Create Git repository (`school-billing-api`)
- [x] Add `.gitignore`
- [x] Initialize Python project (`pyproject.toml` or `requirements.txt`)
- [x] Choose Python version (3.11)

---

## Step 1: Project Architecture ✅
- [x] Create base directory structure:
  - `app/`
    - `core/` (config, database)
    - `models/`
    - `schemas/`
    - `routes/`
    - `services/`
  - `tests/`
  - `alembic/`
- [x] Add initial README with:
  - Project overview
  - Tech stack
  - High-level domain description

---

## Step 2: Database & ORM Setup ✅
- [x] Configure database connection (SQLAlchemy 2.0)
- [x] Define ORM base (`DeclarativeBase`)
- [x] Implement core models:
  - School
  - Student
  - Invoice
  - InvoiceItem (added for better design)
  - Payment
- [x] Define relationships, constraints, and indexes
- [x] Define enums (StudentStatus, InvoiceStatus, PaymentMethod)
- [x] Implement soft deletes (deleted_at column on all models)

---

## Step 3: Migrations (Alembic) ✅
- [x] Initialize Alembic
- [x] Configure Alembic environment to use app settings
- [x] Generate initial migration (core tables)
- [x] Review and adjust autogenerated migration
- [x] Apply migration on empty database
- [x] Additional migrations:
  - Add soft delete support
  - Remove address fields (focus on billing)
  - Make student email and enrollment_date required
- [ ] Document migration workflow in README

---

## Step 4: Docker & Environment Setup ✅
- [x] Create `docker-compose.yml`:
  - PostgreSQL service
  - FastAPI backend service
- [x] Configure environment variables (.env, .env.example)
- [x] Create entrypoint.sh for automatic migrations on startup
- [x] Verify:
  - Database starts
  - Migrations run successfully
  - Application boots without errors

---

## Step 5: FastAPI Application Setup ✅
- [x] Create FastAPI app instance
- [x] Health check endpoint
- [x] Dependency injection for DB sessions
- [x] Baseline exception handling
- [x] OpenAPI metadata (title, description, version)

---

## Step 6: API Schemas & Validation ✅
- [x] Create Pydantic schemas:
  - SchoolCreate / SchoolRead / SchoolUpdate
  - StudentCreate / StudentRead / StudentUpdate
  - InvoiceCreate / InvoiceRead / InvoiceUpdate
  - InvoiceItemCreate / InvoiceItemRead
  - PaymentCreate / PaymentRead
  - StudentAccountStatement / SchoolAccountStatement
- [x] Field validations (amounts > 0, valid dates, required fields)
- [x] Ensure schema ↔ model consistency

---

## Step 7: CRUD Endpoints ⚠️
- [x] CRUD: Schools (with service layer)
- [x] CRUD: Students (with service layer)
- [x] CRUD: Invoices (with service layer, including nested items management)
- [x] Nested routes for invoice items (POST/PATCH/DELETE /invoices/{id}/items/{item_id})
- [x] Nested routes for payments (POST/GET /invoices/{id}/payments)
- [ ] Pagination for list endpoints

---

## Step 8: Business Logic & Rules ✅
- [x] Invoice cannot be overpaid
- [x] Invoice auto-updates status to PAID when fully paid
- [x] Soft deletes (logical deletes with deleted_at)
- [x] Cancel invoice action (POST /invoices/{id}/cancel, not DELETE)
- [x] Invoice total auto-recalculates when items added/updated/deleted
- [x] Cannot delete last invoice item (business invariant)
- [x] Centralize domain logic in `services/` (service layer pattern)
- [x] DDD aggregate pattern (Invoice as aggregate root, nested routes for items/payments)

---

## Step 9: Account Statement Endpoints ✅
- [x] Student account statement:
  - Total invoiced
  - Total paid
  - Total pending
  - Invoice breakdown
- [x] School account statement:
  - Aggregated totals
  - Student count
  - Relevant invoice listing
- [x] Exclude cancelled invoices from totals
- [x] Exclude soft-deleted records
- [ ] Optimize queries (joins + aggregates)

---

## Step 10: Authentication & Authorization (Optional)
- [ ] Basic authentication or token-based auth
- [ ] Protect write endpoints
- [ ] Decide access rules for read endpoints

---

## Step 11: Caching & Performance (Optional)
- [ ] Add Redis service
- [ ] Cache read-heavy endpoints:
  - School account statement
  - Student account statement
- [ ] Invalidate cache on invoice/payment changes

---

## Step 12: Observability ⚠️
- [x] Health check endpoint
- [ ] Structured logging
- [ ] Request/response logging middleware
- [ ] (Optional) basic metrics

---

## Step 13: Testing ❌
- [ ] Configure pytest
- [ ] Test database + migrations
- [ ] Unit tests:
  - Business rules
  - Service layer
- [ ] Integration tests:
  - CRUD endpoints
  - Account statement endpoints

---

## Step 14: Code Quality ❌
- [ ] Add `ruff`
- [ ] Configure linting rules
- [ ] Format entire codebase
- [ ] (Optional) pre-commit hooks

---

## Step 15: Final Documentation ⚠️
- [x] Basic README exists
- [ ] Complete README:
  - Setup instructions
  - Docker commands
  - Migration workflow
  - Test execution
  - API endpoint documentation
- [x] OpenAPI/Swagger documentation (auto-generated by FastAPI)
- [ ] (Optional) sample data loader

---

## Final Deliverable Checklist
- [x] App runs via Docker Compose
- [x] Migrations apply cleanly
- [x] API documented and testable (via OpenAPI/Swagger)
- [x] Business logic clearly separated (service layer)
- [x] Code readable, structured, and maintainable
- [ ] Tests implemented
- [ ] Code quality checks with ruff
- [ ] Complete documentation

---

## Summary

### ✅ Completed (Steps 0-9)
All core functionality is implemented and working:
- Complete CRUD for Schools, Students, Invoices, Payments
- Service layer with business logic
- DDD aggregate pattern with nested routes
- Soft deletes throughout
- Account statement endpoints (student & school)
- Docker Compose setup with automatic migrations
- All business rules implemented

### ⚠️ Partially Complete
- **Step 7**: Missing pagination for list endpoints
- **Step 9**: Could optimize queries with better joins
- **Step 12**: Basic health check only, missing logging/metrics
- **Step 15**: Minimal README, needs expansion

### ❌ Not Started (Optional/Nice-to-have)
- **Step 10**: Authentication & Authorization
- **Step 11**: Caching & Performance (Redis)
- **Step 13**: Testing (pytest, unit tests, integration tests)
- **Step 14**: Code Quality (ruff linting and formatting)
